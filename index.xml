<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grizzly on Grafana Grizzly Docs</title><link>https://grafana.github.io/grizzly/</link><description>Recent content in Grizzly on Grafana Grizzly Docs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 28 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://grafana.github.io/grizzly/index.xml" rel="self" type="application/rss+xml"/><item><title>Grizzly Server</title><link>https://grafana.github.io/grizzly/server/</link><pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/server/</guid><description>An HTTP Server for editing and reviewing When we manage Grafana dashboards on disk, the Grizzly server makes easy to edit and review these resources within an actual Grafana instance, but without needing to publish the dashboard to Grafana. Grafana provides the UI and datasources to make dashboards look right, Grizzly provides the dashboard, directly from local disk.
If the file on disk is writeable (i.e. a pure YAML or JSON file - Jsonnet cannot be written), then clicking the Save icon in Grafana will update your local dashboard file.</description></item><item><title>Hidden Elements</title><link>https://grafana.github.io/grizzly/hidden-elements/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/hidden-elements/</guid><description>NOTE: This functionality is deprecated. It was necessary to support the formats within Monitoring Mixins. However, using explicit resources provides a cleaner and language agnostic way to describe resources and their metadata. If you have existing libaries that use hidden elements, it isn&amp;rsquo;t too hard to write small functions to wrap these into resources.
When working in Jsonnet, Grizzly can detect resources within standardised JSON elements, following a convention of using hidden (::) elements for these.</description></item><item><title>Hidden Elements</title><link>https://grafana.github.io/grizzly/resources/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/resources/</guid><description>NOTE: This functionality is deprecated. It was necessary to support the formats within Monitoring Mixins. However, k8s-style resources provide a cleaner and language agnostic way to describe resources and their metadata.
When working in Jsonnet, Grizzly can detect resources within standardised JSON elements, following a convention of using hidden (::) elements for these.
For example, to specify a simple dashboard:
{ grafanaDashboardFolder:: 'sample', grafanaDashboards+:: { 'my-dash.json': { uid: 'prod-overview', title: 'Production Overview', tags: ['templated'], timezone: 'browser', schemaVersion: 17, }, }, } The grafanaDashboardFolder hidden element specifies the folder that all dashboards will go into.</description></item><item><title>Installation</title><link>https://grafana.github.io/grizzly/installation/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/installation/</guid><description>Grizzly is currently available for Linux and MacOS systems.
Download the latest release.
Select and download an appropriate file for your operating system. Then:
sudo mv $DOWNLOADED_FILE /usr/local/bin/grr sudo chmod +x /usr/local/bin/grr If you wish to build the latest (as yet unreleased) version, assuming you have a recent Golang installed:
git clone https://github.com/grafana/grizzly.git cd grizzly make dev sudo mv grr /usr/local/bin/grr</description></item><item><title>Setup and Configuration</title><link>https://grafana.github.io/grizzly/configuration/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/configuration/</guid><description>Grizzly can be configured in two ways: using environment variables and through Grizzly&amp;rsquo;s own &amp;lsquo;context&amp;rsquo; support (much like kubectl contexts).
Environment variables are suitable for use against a single system, and best suited to CI and automation scenarios.
Grizzly contexts allow easy switching between multiple configurations and are best suited to workstation use.
Using Grizzly Contexts By default, the default context is used. We will discuss how to use the default context first, then explain how to use multiple contexts thereafter.</description></item><item><title>Synthetic Monitoring</title><link>https://grafana.github.io/grizzly/synthetic-monitoring/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/synthetic-monitoring/</guid><description>Grafana Cloud Synthetic Monitoring Checks The only resource type currently configurable by Grizzly is a &amp;ldquo;check&amp;rdquo;, which tells Synthetic Monitoring to periodically check the status of an endpoint.
A synthetic monitoring check requires a name and a type to be specified within its metadata. The type is required as metadata, when it is also included in the spec because it is possible to reuse the same name across checks of different types.</description></item><item><title>Using Jsonnet</title><link>https://grafana.github.io/grizzly/jsonnet/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/jsonnet/</guid><description>Jsonnet is by far the most powerful use-case for Grizzly. It allows resources to be described programmatically, using all the common patterns programmers are familiar with, e.g. variables, libraries and abstractions.
To understand the Jsonnet language, see the Jsonnet tutorial.
Note: The original approach to using Jsonnet in Grizzly involved hidden elements. For details of this deprecated approach, see Hidden Elements.
Here is an example of rendering Prometheus alert and recording rules with Jsonnet:</description></item><item><title>What is Grizzly?</title><link>https://grafana.github.io/grizzly/what-is-grizzly/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/what-is-grizzly/</guid><description>Grafana Grizzly is a command line tool that allows you to manage your observability resources with code.
Now you can define your dashboards, alerting and recording rules, etc, all from within your codebase.
You can build Grizzly into your continuous deployment pipelines, meaning whenever you deploy your application, your observability is updated too.
Getting Started The simplest way to achieve this is using YAML resource descriptions. (Programmatic description is explained in the section on Jsonnet).</description></item><item><title>With Grafana</title><link>https://grafana.github.io/grizzly/grafana/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/grafana/</guid><description>Dashboards In What is Grizzly? we saw an example of how to manage a Grafana dashboard.
When representing a dashboard, the JSON that is downloaded from Grafana should be placed into the spec element. If using YAML, the JSON should be converted to YAML before doing so.
Folders Grafana dashboard folders are probably the simplest resources you can manage with Grizzly:
apiVersion: grizzly.grafana.com/v1alpha1 kind: DashboardFolder metadata: name: sample spec: title: Special Sample Folder A folder simply has a name and a title.</description></item><item><title>With Prometheus</title><link>https://grafana.github.io/grizzly/prometheus/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/prometheus/</guid><description>Which Prometheus' are supported? Prometheus itself requires its configuration to be present in text files on local disk. As Grizzly focuses on systems that can be managed via HTTP APIs, Grizzly cannot (currently) work with Prometheus itself.
Various hosted Prometheus installations, such as Grafana Cloud Prometheus are supported, as are systems running Cortex.
Configuring Prometheus Prometheus alert and recording rules are both created using the same kind: PrometheusRuleGroup. Rule groups need to be placed into a namespace - namespaces simply group these rule groups together.</description></item><item><title>Workflows</title><link>https://grafana.github.io/grizzly/workflows/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/workflows/</guid><description>Grizzly supports a number of workflows.
Static Resources All examples so far have described Grizzly interacting with resources represented as static resources in YAML. This is the simplest use-case for Grizzly, but there are more powerful workflows available.
Pull/Push With grr pull -d and grr apply -d it is possible to migrate dashboards between Grafana instances. To pull dashboards and folders from one instance to another is as simple as:</description></item><item><title>authentication</title><link>https://grafana.github.io/grizzly/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://grafana.github.io/grizzly/authentication/</guid><description>Moved to Setup and Configuration.</description></item></channel></rss>