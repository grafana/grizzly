package grafana

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/grafana/grizzly/pkg/grizzly"
	"github.com/grafana/synthetic-monitoring-agent/pkg/pb/synthetic_monitoring"
	smapi "github.com/grafana/synthetic-monitoring-api-go-client"
)

/*
 * @TODO
 * 1. The API does not have a GET method, so we have to fake it here
 * 2. The API expects an ID and a tenantId in an update, but these are
 *    generated by the server so cannot be represented in Jsonnet.
 *    Therefore, we have to pre-retrieve the check to get those values
 *    so we can inject them before posting JSON.
 * 3. This means pre-retrieving the check *twice*, once to establish
 *    whether this resource has changed or not (within Grizzly ifself)
 *    and again within this provider to retrieve IDs. Not ideal.
 * 4. The API expects probes to be specified by ID. This is not
 *    user-friendly. This code therefore takes in strings, and converts
 *    them to IDs, having requested an ID<->string mapping from the API.
 */

const smBaseURL = "https://synthetic-monitoring-api.grafana.net"

type Probes struct {
	ByID   map[int64]synthetic_monitoring.Probe
	ByName map[string]synthetic_monitoring.Probe
}

// NewSyntheticMonitoringClient creates a new client for synthetic monitoring go client
func NewSyntheticMonitoringClient() (*smapi.Client, error) {
	client, err := NewHttpClient()
	if err != nil {
		return nil, err
	}

	smClient := smapi.NewClient(smBaseURL, "", client)

	apiToken, ok := os.LookupEnv("GRAFANA_SM_TOKEN")
	if !ok {
		return nil, fmt.Errorf("GRAFANA_SM_TOKEN environment variable must be set")
	}

	stackID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_STACK_ID"))
	if err != nil {
		return nil, fmt.Errorf("GRAFANA_SM_STACK_ID environment variable must be set")
	}
	metricsInstanceID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_METRICS_ID"))
	if err != nil {
		return nil, fmt.Errorf("GRAFANA_SM_METRICS_ID environment variable must be set")
	}
	logsInstanceID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_LOGS_ID"))
	if err != nil {
		return nil, fmt.Errorf("GRAFANA_SM_LOGS_ID environment variable must be set")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err = smClient.Install(ctx, int64(stackID), int64(metricsInstanceID), int64(logsInstanceID), apiToken)
	if err != nil {
		return nil, fmt.Errorf("failed to install synthetic monitoring client : %v", err)
	}

	return smClient, nil
}

// getProbeList retrieves the list of probe and grouped by id and name
func getProbeList() (Probes, error) {
	smClient, err := NewSyntheticMonitoringClient()
	if err != nil {
		return Probes{}, err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	probeList, err := smClient.ListProbes(ctx)
	if err != nil {
		return Probes{}, fmt.Errorf("failed to initialize probes list: %v", err)
	}

	probes := Probes{
		ByID:   map[int64]synthetic_monitoring.Probe{},
		ByName: map[string]synthetic_monitoring.Probe{},
	}

	for _, probe := range probeList {
		if probe.Online && probe.Public {
			probes.ByID[probe.Id] = probe
			probes.ByName[probe.Name] = probe
		}
	}
	return probes, nil
}

// getRemoteCheck retrieves a check object from SM
func getRemoteCheckList() ([]string, error) {
	smClient, err := NewSyntheticMonitoringClient()
	if err != nil {
		return nil, err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	checks, err := smClient.ListChecks(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get checks list: %v", err)
	}
	var checkIDs []string

	for _, check := range checks {
		checkIDs = append(checkIDs, getUID(check))
	}
	return checkIDs, nil
}

// getRemoteCheck retrieves a check object from SM
func getRemoteCheck(uid string) (*grizzly.Resource, error) {
	smClient, err := NewSyntheticMonitoringClient()
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	checkList, err := smClient.ListChecks(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get checks list: %v", err)
	}

	probes, err := getProbeList()
	if err != nil {
		return nil, err
	}

	for _, check := range checkList {
		if getUID(check) == uid {
			var probeNames []string
			for _, probeID := range check.Probes {
				probeNames = append(probeNames, probes.ByID[probeID].Name)
			}
			handler := SyntheticMonitoringHandler{}
			data, err := json.Marshal(check)
			if err != nil {
				return nil, err
			}
			var specmap map[string]interface{}
			err = json.Unmarshal(data, &specmap)
			if err != nil {
				return nil, err
			}
			specmap["probes"] = probeNames
			resource := grizzly.NewResource(handler.APIVersion(), handler.Kind(), check.Job, specmap)
			resource.SetMetadata("type", getType(check))
			return &resource, nil
		}
	}
	return nil, grizzly.ErrNotFound
}

func convertProbeNameToID(resource *grizzly.Resource) error {
	probes, err := getProbeList()
	if err != nil {
		return err
	}
	var probeIDs []int64

	for _, probename := range (*resource).GetSpecValue("probes").([]interface{}) {
		probeName := probename.(string)
		id := probes.ByName[probeName].Id
		probeIDs = append(probeIDs, id)
	}
	(*resource).SetSpecValue("probes", probeIDs)
	return nil
}

func addCheck(resource grizzly.Resource) error {
	smClient, err := NewSyntheticMonitoringClient()
	if err != nil {
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = convertProbeNameToID(&resource)
	if err != nil {
		return err
	}

	theCheck, err := SpecToCheck(&resource)
	if err != nil {
		return fmt.Errorf("input file is invalid: %v", err)
	}
	_, err = smClient.AddCheck(ctx, theCheck)
	if err != nil {
		return err
	}
	return nil
}

func updateCheck(resource grizzly.Resource) error {
	smClient, err := NewSyntheticMonitoringClient()
	if err != nil {
		return err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = convertProbeNameToID(&resource)
	if err != nil {
		return err
	}

	theCheck, err := SpecToCheck(&resource)
	if err != nil {
		return fmt.Errorf("input file is invalid: %v", err)
	}
	_, err = smClient.UpdateCheck(ctx, theCheck)
	if err != nil {
		return err
	}

	return nil
}

func SpecToCheck(r *grizzly.Resource) (synthetic_monitoring.Check, error) {
	var smCheck synthetic_monitoring.Check
	data, err := json.Marshal((*r)["spec"])
	if err != nil {
		return synthetic_monitoring.Check{}, nil
	}

	err = json.Unmarshal(data, &smCheck)
	if err != nil {
		return synthetic_monitoring.Check{}, nil
	}

	return smCheck, nil
}

// Probes allows accessing Probe objects by ID and by name
func getType(check synthetic_monitoring.Check) string {
	if check.Settings.Ping != nil {
		return "ping"
	}
	if check.Settings.Http != nil {
		return "http"
	}
	if check.Settings.Tcp != nil {
		return "tcp"
	}
	if check.Settings.Dns != nil {
		return "dns"
	}
	return ""
}

func getUID(check synthetic_monitoring.Check) string {
	return fmt.Sprintf("%s.%s", getType(check), check.Job)
}
