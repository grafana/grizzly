package grafana

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"

	"github.com/grafana/grizzly/pkg/grizzly"
)

/*
 * @TODO
 * 1. The API does not have a GET method, so we have to fake it here
 * 2. The API expects an ID and a tenantId in an update, but these are
 *    generated by the server so cannot be represented in Jsonnet.
 *    Therefore, we have to pre-retrieve the check to get those values
 *    so we can inject them before posting JSON.
 * 3. This means pre-retrieving the check *twice*, once to establish
 *    whether this resource has changed or not (within Grizzly ifself)
 *    and again within this provider to retrieve IDs. Not ideal.
 * 4. The API expects probes to be specified by ID. This is not
 *    user-friendly. This code therefore takes in strings, and converts
 *    them to IDs, having requested an ID<->string mapping from the API.
 */

const smURL = "https://synthetic-monitoring-api.grafana.net/%s"

// getRemoteCheck retrieves a check object from SM
func getRemoteCheck(uid string) (*Check, error) {
	url := getURL("api/v1/check/list")
	authToken, err := getAuthToken()
	if err != nil {
		return nil, err
	}
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", "Bearer "+authToken)
	req.Header.Add("Content-type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotFound:
		return nil, grizzly.ErrNotFound
	default:
		if resp.StatusCode >= 400 {
			return nil, errors.New(resp.Status)
		}
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var checks []Check
	if err := json.Unmarshal(data, &checks); err != nil {
		return nil, grizzly.APIErr{Err: err, Body: data}
	}
	probes, err := getProbeList()
	if err != nil {
		return nil, err
	}
	for _, check := range checks {
		if check.UID() == uid {
			probeNames := []string{}
			for _, probe := range check["probes"].([]interface{}) {
				probeID := int(probe.(float64))
				name := probes.ByID[probeID].Name
				probeNames = append(probeNames, name)
			}
			check["probes"] = probeNames
			return &check, nil
		}
	}
	return nil, grizzly.ErrNotFound
}

func postCheck(url string, check Check) error {
	checkJSON, err := check.toJSON()
	if err != nil {
		return err
	}

	client := &http.Client{}
	accessToken, err := getAuthToken()
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewBufferString(checkJSON))
	if err != nil {
		return err
	}
	req.Header.Add("Authorization", "Bearer "+accessToken)
	req.Header.Add("Content-type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return err
	}

	switch resp.StatusCode {
	case http.StatusOK:
		break
	default:
		return fmt.Errorf("Non-200 response from Grafana Synthetic Monitoring while applying '%s': %s", resp.Status, check.UID())
	}
	return nil
}

// Probe defines the properties of a single SM Probe
type Probe struct {
	ID       int    `json:"id"`
	TenantID int    `json:"tenantId"`
	Name     string `json:"name"`
	Region   string `json:"region"`
	Public   bool   `json:"public"`
	Online   bool   `json:"online"`
}

// Probes allows accessing Probe objects by ID and by name
type Probes struct {
	ByID   map[int]Probe
	ByName map[string]Probe
}

// getRemoteCheck retrieves a check object from SM
func getProbeList() (*Probes, error) {
	url := getURL("api/v1/probe/list")
	authToken, err := getAuthToken()
	if err != nil {
		return nil, err
	}
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", "Bearer "+authToken)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotFound:
		return nil, grizzly.ErrNotFound
	default:
		if resp.StatusCode >= 400 {
			return nil, errors.New(resp.Status)
		}
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	probeList := []Probe{}
	if err := json.Unmarshal(data, &probeList); err != nil {
		return nil, grizzly.APIErr{Err: err, Body: data}
	}
	probes := Probes{
		ByID:   map[int]Probe{},
		ByName: map[string]Probe{},
	}
	for _, probe := range probeList {
		if probe.Online && probe.Public {
			probes.ByID[probe.ID] = probe
			probes.ByName[probe.Name] = probe
		}
	}
	return &probes, nil
}

// Check encapsulates a check
type Check map[string]interface{}

func newCheck(resource grizzly.Resource) Check {
	return resource.Detail.(Check)
}

// UID retrieves the UID from a check
func (c *Check) UID() string {
	job, ok := (*c)["job"]
	if !ok {
		return "X"
	}
	settings, ok := (*c)["settings"]
	if !ok {
		return "Y"
	}
	for typ := range settings.(map[string]interface{}) {
		return fmt.Sprintf("%s-%s", typ, job)
	}
	return "NIL"
}

// toJSON returns JSON for a datasource
func (c *Check) toJSON() (string, error) {
	probes, err := getProbeList()
	if err != nil {
		return "", err
	}
	probeIDs := []int{}
	for _, probe := range (*c)["probes"].([]interface{}) {
		probeName := probe.(string)
		id := probes.ByName[probeName].ID
		probeIDs = append(probeIDs, id)
	}
	(*c)["probes"] = probeIDs

	j, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return "", err
	}
	return string(j), nil
}

func getURL(path string) string {
	return fmt.Sprintf(smURL, path)
}

func getAuthToken() (string, error) {
	url := getURL("api/v1/register/install")
	apiToken, ok := os.LookupEnv("GRAFANA_SM_TOKEN")
	if !ok {
		return "", fmt.Errorf("GRAFANA_SM_TOKEN environment variable must be set.")
	}

	stackID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_STACK_ID"))
	if err != nil {
		return "", fmt.Errorf("GRAFANA_SM_STACK_ID environment variable must be set.")
	}
	metricsInstanceID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_METRICS_ID"))
	if err != nil {
		return "", fmt.Errorf("GRAFANA_SM_METRICS_ID environment variable must be set.")
	}
	logsInstanceID, err := strconv.Atoi(os.Getenv("GRAFANA_SM_LOGS_ID"))
	if err != nil {
		return "", fmt.Errorf("GRAFANA_SM_LOGS_ID environment variable must be set.")
	}

	type AuthRequest struct {
		StackID           int `json:"stackId"`
		MetricsInstanceID int `json:"metricsInstanceId"`
		LogsInstanceID    int `json:"logsInstanceId"`
	}

	authRequest := AuthRequest{
		StackID:           stackID,
		MetricsInstanceID: metricsInstanceID,
		LogsInstanceID:    logsInstanceID,
	}

	authRequestJSON, err := json.Marshal(authRequest)
	if err != nil {
		return "", err
	}

	client := &http.Client{}
	req, err := http.NewRequest("POST", url, bytes.NewReader(authRequestJSON))
	req.Header.Add("Authorization", "Bearer "+apiToken)
	req.Header.Add("Content-type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := ioutil.ReadAll(resp.Body)
		return "", fmt.Errorf("%d response while authenticating: %s", resp.StatusCode, string(body))
	}
	type AuthResponse struct {
		AccessToken string `json:"accessToken"`
	}
	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	authResponse := AuthResponse{}
	if err := json.Unmarshal(data, &authResponse); err != nil {
		return "", grizzly.APIErr{Err: err, Body: data}

	}
	return authResponse.AccessToken, nil
}
